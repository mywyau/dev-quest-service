Great—here’s a tight, do‑this‑next checklist for your backend. It’s ordered so you can stop after any phase and still have a working system.

Phase 1 — Fast list/search with Postgres (no queues yet)
Flyway migrations (small files)

V10__quest_view.sql – create quest_view, quest_user_view, indexes.

V11__seed_quest_view_trigger.sql – trigger to insert a base row on quests insert.

(Optional) V12__quest_view_title_tsv_trigger.sql – maintain title_tsv.

Endpoint

GET /quests/search that queries only quest_view with keyset pagination and filters: status, clientId, tags, q, sort.

Make sure indexes exist for your WHERE/ORDER BY.

Code

modules/questsview/QuestViewRepo.scala – Doobie queries (keyset).

modules/questsview/QuestViewRoutes.scala – http4s route.

Return items + nextCursor.

✅ Done = p95 < ~80–120 ms, no joins on the hot path.

Phase 2 — Outbox foundations (still no queue)
Flyway

V20__events_outbox.sql

V21__processed_messages.sql (consumer idempotency, used later)

Emit events (same DB txn)

On these writes: QuestCreated/Updated/StatusChanged, BidPlaced/Updated/Withdrawn, EstimateAdded/Updated/Withdrawn, RewardUpdated, SubmissionUploaded, QuestAssigned/Unassigned.

Add a small OutboxRepo.insert(event) call inside each service’s transaction.

Contracts module

modules/contracts/DomainEvent.scala – case classes + Circe codecs, versioned names like BidPlaced.v1.

✅ Done = your writes now leave a durable trail to build on.

Phase 3 — Queue + Projector (keeps quest_view fresh asynchronously)
Infra

Create SQS queue + DLQ: quest-view-projector.

Expose queue URL via env var.

Dispatcher

modules/outbox/OutboxDispatcher.scala – polls events_outbox in small batches, publishes to SQS, marks published_at.

Projector worker

New main: workers/QuestViewProjectorMain.scala (FS2 loop).

Handler updates (UPSERTs) in quest_view:

Bid* → bids_count, min_bid, max_bid, last_activity_at

Estimate* → estimates_count, avg_estimated_hours, last_activity_at

Quest* → base fields, title_tsv, last_activity_at

RewardUpdated, Submission*, Assignment*, EstimationWindow* → respective columns

Idempotent: check processed_messages.

Version‑safe: compare per‑source *_v or updated_at.

Config switches

Feature‑flag the triggers off once projector is live (USE_TRIGGERS=false), or just leave them until you’re confident.

✅ Done = list/search stays fast even under write spikes.

Phase 4 — OpenSearch (only if you need rich text/facets)
Infra

Managed OpenSearch domain (or run locally via Docker for dev).

Index quests with mapping: analyzed title/text, keyword status/clientId/tags, numeric aggregates, createdAt, updatedAt, title_sort.

Search indexer worker

workers/SearchIndexerMain.scala – consumes the same SQS events.

Builds a denormalized doc; does bulk upserts.

Supports search_after for deep pagination.

API

Keep one endpoint /quests/search.

If q (free‑text) present → query OpenSearch. Otherwise → Postgres quest_view.

✅ Done = flexible, fast search with relevance + facets.

Minimal code stubs (names you can copy)
Events (contracts)

scala
Copy
Edit
sealed trait DomainEvent { def id: String; def aggregateId: String; def occurredAt: Instant; def `type`: String }
final case class BidPlacedV1(id: String, aggregateId: String, devId: String, amount: BigDecimal, occurredAt: Instant)
  extends DomainEvent { val `type` = "BidPlaced.v1" }
Emit outbox in the same txn

scala
Copy
Edit
def placeBid(cmd: PlaceBid): ConnectionIO[Unit] =
  for {
    _ <- sql"""INSERT INTO dev_bids(quest_id, dev_id, dev_username, bid)
               VALUES (${cmd.questId}, ${cmd.devId}, ${cmd.username}, ${cmd.amount})
               ON CONFLICT (quest_id, dev_id)
               DO UPDATE SET bid = EXCLUDED.bid, updated_at = now()""".update.run
    _ <- outbox.insert(
           "Bid", cmd.questId, "BidPlaced.v1",
           json"""{"questId": ${cmd.questId}, "devId": ${cmd.devId}, "amount": ${cmd.amount}}""",
           dedupeKey = Some(java.util.UUID.randomUUID.toString)
         )
  } yield ()
Projector UPSERT (example for bids)

sql
Copy
Edit
INSERT INTO quest_view(quest_id, bids_count, min_bid, max_bid, last_activity_at, bids_v)
SELECT $qid, COUNT(*), MIN(bid), MAX(bid), MAX(updated_at),
       EXTRACT(EPOCH FROM MAX(updated_at))::bigint
FROM dev_bids WHERE quest_id = $qid
GROUP BY quest_id
ON CONFLICT (quest_id) DO UPDATE
SET bids_count = EXCLUDED.bids_count,
    min_bid    = EXCLUDED.min_bid,
    max_bid    = EXCLUDED.max_bid,
    last_activity_at = GREATEST(quest_view.last_activity_at, EXCLUDED.last_activity_at),
    bids_v = GREATEST(quest_view.bids_v, EXCLUDED.bids_v);
Keyset query (Doobie uses this SQL)

sql
Copy
Edit
SELECT quest_id, title, status, tags, created_at,
       bids_count, min_bid, estimates_count, avg_estimated_hours, reward_completion_total
FROM quest_view
WHERE (:status   IS NULL OR status = :status)
  AND (:clientId IS NULL OR client_id = :clientId)
  AND (:tags     IS NULL OR tags && :tags)
  AND (:q        IS NULL OR title_tsv @@ plainto_tsquery('english', :q))
  AND (:afterCreatedAt IS NULL OR (created_at, quest_id) < (:afterCreatedAt, :afterId))
ORDER BY created_at DESC, quest_id DESC
LIMIT :limit + 1;
Local/dev setup that won’t hurt
Start with triggers only (no queue): fastest to verify quest_view + endpoint.

Add an InMemoryBus implementation for events to run everything in‑proc.

When ready, swap to SQS (or LocalStack) via config and start the projector process.

Acceptance criteria (use this to know you’re done)
/quests/search consistently < 120 ms p95 with realistic data.

New quest shows on the list immediately; aggregates appear within your SLA (triggers: immediate; projector: sub‑second).

Backfill job exists to rebuild quest_view from source tables.

(If using queues) DLQ is empty; alarm on queue age in place.

If you want, I can turn this into a small GitHub issue checklist (with file paths) or draft the Flyway SQL files split into logical chunks so you can paste them straight into db/migration.







You said:
what goes in 

V11__seed_quest_view_trigger.sql


ChatGPT said:
Your V11__seed_quest_view_trigger.sql is basically the migration that makes sure every new quest insert automatically gets a base row in quest_view, so the list/search page never shows “missing” entries even if bids, estimates, rewards, etc. haven’t been added yet.

It’s the “safety net” so you don’t need the projector running for the base data to appear.

Example V11__seed_quest_view_trigger.sql
sql
Copy
Edit
-- Create the read model table if not already created
-- (If you made it in V10__quest_view.sql, skip this CREATE)
CREATE TABLE IF NOT EXISTS quest_view (
    quest_id VARCHAR(255) PRIMARY KEY,
    title TEXT,
    status VARCHAR(50),
    client_id VARCHAR(255),
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    tags TEXT[] DEFAULT '{}',
    -- Aggregated fields
    bids_count INT DEFAULT 0,
    min_bid NUMERIC,
    max_bid NUMERIC,
    estimates_count INT DEFAULT 0,
    avg_estimated_hours NUMERIC,
    reward_completion_total NUMERIC,
    reward_time_total NUMERIC,
    last_activity_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    -- Optional "version" columns for projector
    quest_v BIGINT DEFAULT 0,
    bids_v BIGINT DEFAULT 0,
    estimates_v BIGINT DEFAULT 0,
    rewards_v BIGINT DEFAULT 0
);

-- Function to insert a base quest_view row on quest insert
CREATE OR REPLACE FUNCTION seed_quest_view()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO quest_view (
        quest_id,
        title,
        status,
        client_id,
        created_at,
        updated_at,
        tags,
        quest_v,
        last_activity_at
    )
    VALUES (
        NEW.quest_id,
        NEW.title,
        NEW.status,
        NEW.client_id,
        NEW.created_at,
        NEW.updated_at,
        COALESCE(NEW.tags, '{}'),
        EXTRACT(EPOCH FROM NEW.updated_at)::bigint,
        NEW.created_at
    )
    ON CONFLICT (quest_id) DO NOTHING;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to call the seed function after quests insert
DROP TRIGGER IF EXISTS trg_seed_quest_view ON quests;

CREATE TRIGGER trg_seed_quest_view
AFTER INSERT ON quests
FOR EACH ROW
EXECUTE FUNCTION seed_quest_view();
What this does
When a quest is created, it inserts a matching row in quest_view immediately.

That row has:

quest_id, title, status, client_id

Timestamps

An empty tags array if none given

Aggregated fields set to defaults (bids_count=0, etc.)

If the row already exists (e.g., backfill or projector already created it), ON CONFLICT DO NOTHING avoids errors.

You still rely on the projector later to update aggregates and extra fields.

Why it’s important
Without this, the “View All Quests” page could be empty until the projector runs and inserts the row.

With it, users see the quest in the list immediately after creation — even before bids, estimates, or rewards exist.

If you want, I can also give you the matching update triggers for dev_bids, quest_estimations, and reward so the aggregates in quest_view stay in sync synchronously until you move that logic to the message-queue projector. That way you don’t have a gap while implementing the async path.